#include <zephyr.h>
#include <sys/printk.h>
#include <drivers/gpio.h>
#include <bluetooth/bluetooth.h>
#include <bluetooth/mesh.h>
#include <settings/settings.h>
#include <bluetooth/mesh/proxy.h>

#include <../lib/models/sensor_cli.h>
#include <../lib/models/gen_onoff_cli.h>

// GPIO for the buttons
#define SW0_NODE	DT_ALIAS(sw0)

#if DT_NODE_HAS_STATUS(SW0_NODE, okay)
#define SW0_GPIO_LABEL	DT_GPIO_LABEL(SW0_NODE, gpios)
#define SW0_GPIO_PIN	DT_GPIO_PIN(SW0_NODE, gpios)
#define SW0_GPIO_FLAGS	(GPIO_INPUT | DT_GPIO_FLAGS(SW0_NODE, gpios) | GPIO_INT_EDGE)
#else
#error "Unsupported board: sw0 devicetree alias is not defined"
#endif

#define BUTTON_DEBOUNCE_DELAY_MS 250

#define GAS_TRIGGER_THRESHOLD 800

// for debouncing the button
static uint32_t btn_time = 0;
static uint32_t btn_last_time = 0;

static struct gpio_callback button_cb_data;

// GPIO for LED 0
const struct device *led;
int op_id = 0;

#define LED0_NODE	DT_ALIAS(led0)

#if DT_NODE_HAS_STATUS(LED0_NODE, okay) && DT_NODE_HAS_PROP(LED0_NODE, gpios)
#define LED0_GPIO_LABEL	DT_GPIO_LABEL(LED0_NODE, gpios)
#define LED0_GPIO_PIN	DT_GPIO_PIN(LED0_NODE, gpios)
#define LED0_GPIO_FLAGS	(GPIO_OUTPUT | DT_GPIO_FLAGS(LED0_NODE, gpios))
#else
#error "Unsupported board: led0 devicetree alias is not defined"
#endif

static const uint8_t dev_uuid[16] = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x00 };


void led_on(void) {
	printk("turning led on\n");
	gpio_pin_set(led, LED0_GPIO_PIN, 1);
}

void led_off(void) {
	printk("turning led off\n");
	gpio_pin_set(led, LED0_GPIO_PIN, 0);
}

static void attention_on(struct bt_mesh_model *model) {
	printk("attention_on\n");
	led_on();
}

static void attention_off(struct bt_mesh_model *model) {
	printk("attention_off\n");
	led_off();
}

static const struct bt_mesh_health_srv_cb health_srv_cb = {
	.attn_on = attention_on,
	.attn_off = attention_off,
};

// called to output the provisioned number
static int provisioning_output_pin(bt_mesh_output_action_t act, uint32_t num) {
	printk("OOB number: %04d\n", num);
	return 0;
}

static void provisioning_complete(uint16_t net_idx, uint16_t addr) {
	printk("Provisioning complete\n");
}

static void provisioning_reset(void) {
	bt_mesh_prov_enable(BT_MESH_PROV_ADV | BT_MESH_PROV_GATT);
}

// provisioning properties and capabilities
static const struct bt_mesh_prov prov = {
	.uuid = dev_uuid,
	// Authenticate the device by displaying a 4 digit PIN
	.output_size = 4,
	.output_actions = BT_MESH_DISPLAY_NUMBER,
	.output_number = provisioning_output_pin, // callback called with a rndm number generated by the bt stack
	.complete = provisioning_complete,
	.reset = provisioning_reset, // called on provisioning abandoned
};


// -------------------------------------------------------------------------------------------------------
// Configuration Server
// --------------------
static struct bt_mesh_cfg_srv cfg_srv = {
	.relay = BT_MESH_RELAY_DISABLED,
	.beacon = BT_MESH_BEACON_DISABLED,
	.frnd = BT_MESH_FRIEND_NOT_SUPPORTED,
	// enabled to allow provisioning over GATT, which is supported by nRF Mesh Application
	.gatt_proxy = BT_MESH_GATT_PROXY_ENABLED,
	.default_ttl = 7,
	// 3 transmissions with 20ms interval
	.net_transmit = BT_MESH_TRANSMIT(2, 20)
};


// -------------------------------------------------------------------------------------------------------
// Health Server
// -------------
// This model can publish diagnostic messages. Macro used to define publication context
BT_MESH_HEALTH_PUB_DEFINE(health_pub, 0);
static struct bt_mesh_health_srv health_srv = {
	.cb = &health_srv_cb,
};

// -------------------------------------------------------------------------------------------------------
// Composition
// -----------

static struct bt_mesh_model sig_models[] = {
	BT_MESH_MODEL_CFG_SRV(&cfg_srv),
	BT_MESH_MODEL_HEALTH_SRV(&health_srv, &health_pub),
	GEN_ONOFF_CLI_MODEL,
	SENSOR_CLIENT_MODEL,
};

// define the element(s) which contain the previously defined models
static struct bt_mesh_elem elements[] = {
	BT_MESH_ELEM(0, sig_models, BT_MESH_MODEL_NONE), // .._MODEL_NONE means no vendor models
};

// define the node containing the elements (composition)
static const struct bt_mesh_comp comp = {
	.cid = 0xFFFF, // test value company id 
	.elem = elements,
	.elem_count = ARRAY_SIZE(elements),
};

// -------------------------------------------------------------------------------------------------------
// Data callbacks
// -------
void thp_data_callback(float temperature, float humidity, float pressure, uint16_t recv_dest) {
	printf("\n\nthp_data_callback received temp: %.2f, hum: %.2f, press: %.2f. Pub address: 0x%02x\n\n", temperature, humidity, pressure, recv_dest);
	// TODO forward to Raspberry Pi
}

void gas_data_callback(uint16_t ppm, uint16_t recv_dest) {
	printf("\n\ngas_data_callback received ppm: %d. Pub address: 0x%02x\n\n", ppm, recv_dest);
	
	if (ppm > GAS_TRIGGER_THRESHOLD) {
		led_on();
	} else {
		led_off();
	}
	
	// TODO forward to Raspberry Pi
}


// -------------------------------------------------------------------------------------------------------
// LED
// -------

void initialize_led(void) {
	printk("initializeLED\n");
	int ret;

	led = device_get_binding(LED0_GPIO_LABEL);

	if (led == NULL) {
		printk("Didn't find LED device %s\n", LED0_GPIO_LABEL);
		return;
	}

	ret = gpio_pin_configure(led, LED0_GPIO_PIN, GPIO_OUTPUT_ACTIVE | LED0_GPIO_FLAGS);
	if (ret != 0) {
		printk("Error %d: failed to configure LED device %s pin %d\n",
		       ret, LED0_GPIO_LABEL, LED0_GPIO_PIN);
		return;
	}

	printk("Set up LED at %s pin %d\n", LED0_GPIO_LABEL, LED0_GPIO_PIN);
	led_off();
}

// -------------------------------------------------------------------------------------------------------
// Buttons
// -------

bool debounce() {
	bool ignore = false;
	btn_time = k_uptime_get_32();
	if (btn_time < (btn_last_time + BUTTON_DEBOUNCE_DELAY_MS)) {
		ignore = true;
	} else {
		ignore = false;
	}
	btn_last_time = btn_time;
	return ignore;
}

void button_pressed(const struct device *dev, struct gpio_callback *cb, uint32_t pins) {	
	if (!debounce()) {
		printk("Button pressed at %" PRIu32 "\n", k_cycle_get_32());
		
		if (op_id % 4 == 0) {
			gen_onoff_set_unack(0);
		} else if (op_id % 4 == 1) {
			gen_onoff_set_unack(1);
		} else if (op_id % 4 == 2) {
			gen_onoff_get(&sig_models[2]);
		} else if (op_id % 4 == 3) {
			sensor_cli_get(&sig_models[3]);
		}
		
		op_id++;
	}
}

void configure_buttons(void)
{
	int ret;
	printk("configure_buttons\n");

	const struct device *button;

	button = device_get_binding(SW0_GPIO_LABEL);
	if (button == NULL) {
		printk("Error: didn't find %s device\n", SW0_GPIO_LABEL);
		return;
	}

	ret = gpio_pin_configure(button, SW0_GPIO_PIN, SW0_GPIO_FLAGS);
	if (ret != 0) {
		printk("Error %d: failed to configure %s pin %d\n",
		       ret, SW0_GPIO_LABEL, SW0_GPIO_PIN);
		return;
	}

	ret = gpio_pin_interrupt_configure(button,
					   SW0_GPIO_PIN,
					   GPIO_INT_EDGE_TO_ACTIVE);
	if (ret != 0) {
		printk("Error %d: failed to configure interrupt on %s pin %d\n",
			ret, SW0_GPIO_LABEL, SW0_GPIO_PIN);
		return;
	}

	gpio_init_callback(&button_cb_data, button_pressed, BIT(SW0_GPIO_PIN));
	gpio_add_callback(button, &button_cb_data);
	printk("Set up button at %s pin %d\n", SW0_GPIO_LABEL, SW0_GPIO_PIN);

}

static void bt_ready(int err) {
	if(err) {
		printk("bt_enable failed with with err %d\n", err);
		return;
	}

	printk("Bluetooth initialized\n");
	
	err = bt_mesh_init(&prov, &comp);
	if(err) {
		printk("bt_mesh_init failed with err %d\n", err);
		return;
	}

	printk("Mesh initialized\n");
	if (IS_ENABLED(CONFIG_SETTINGS)) {
		// restore persisted data including mesh stack variables (e.g. net key and app key if provisioned)
		settings_load();
		printk("Settings loaded\n");
	}

	if (bt_mesh_is_provisioned()) {
		printk("Node has already been provisioned\n");
	} else {
		printk("Node has not been provisioned: beaconing\n");
		bt_mesh_prov_enable(BT_MESH_PROV_ADV | BT_MESH_PROV_GATT); // provision using either gatt or advertising bearer
	}
	
}


void main(void) {
	int err;
	printk("thingy switch node\n");

	onoff_tid = 0;

	configure_buttons();

	initialize_led();
	
	err = bt_enable(bt_ready);
	if (err)
	{
		printk("bt_enable failed with err %d\n", err);
	}
	
	sensor_cli_set_thp_callback(&thp_data_callback);
	sensor_cli_set_gas_callback(&gas_data_callback);
}
